# parsl/serialize/concretes.py:10: error: Module "proxystore.store" does not explicitly export attribute "Store"  [attr-defined]
from proxystore.store import Store, register_store  # type: ignore
from proxystore.connectors.file import FileConnector
from parsl.serialize.facade import register_serializer

from parsl.serialize.base import SerializerBase

from typing import Any, Optional

import dill

import io

import logging

from typing import Type

logger = logging.getLogger(__name__)

class ProxyStoreDeepPickler(dill.Pickler):

    def __init__(self, *args, policy, store, **kwargs):
        super().__init__(*args, **kwargs)
        self._store = store
        self._policy = policy

    def reducer_override(self, o):
        logger.info(f"BENC: reducing object {o}")

        if type(o) is self._policy: # not isinstance, because don't want subclasses (like bool<int)
            logger.info(f"BENC: Policy class detected")
            proxy = self._store.proxy(o)
            return proxy.__reduce__()
        else:
            # fall through to pickle...
            return NotImplemented


class ProxyStoreDeepSerializer(SerializerBase):
    # TODO: better enforcement of this being bytes, because that's common error i'm making
    # and probably it should be autogenerated...
    _identifier = b'parsl.serialize.plugin_proxystore_deep_pickle ProxyStoreDeepSerializer'  # must be class name
    _for_code = True
    _for_data = True

    def __init__(self, *, policy: Type = None, store: Optional[Store] = None) -> None:
        """Because of jumbled use of this class for init-time configurable
        serialization, and non-configurable remote deserializer loading, the
        store and policy fields can be None... TODO: this would go away if serializer and
        deserializer were split into different objects/classes/functions, like Pickler and
        Unpickler are"""
        self._store = store
        self._policy = policy

    def serialize(self, data: Any) -> bytes:
        assert self._store is not None
        assert self._policy is not None

        assert data is not None

        # TODO: pluggable policy should go here... what does that look like?
        # TODO: this policy belongs in the pickler plugin, not top level parsl serializer plugin
        # if not isinstance(data, int):
        #    raise RuntimeError(f"explicit policy will only proxy ints, not {type(data)}")

        f = io.BytesIO()
        pickler = ProxyStoreDeepPickler(file=f, store=self._store, policy=self._policy)
        pickler.dump(data)
        return f.getvalue()

    def deserialize(self, body: bytes) -> Any:
        # because we aren't customising deserialization, use regular
        # dill for deserialization; but otherwise could create a
        # custom Unpickler here...
        return dill.loads(body)


def register_proxystore_serializer() -> None:
    """Initializes proxystore and registers it as a serializer with parsl"""
    serializer = create_proxystore_serializer_deep_pickle()
    register_serializer(serializer)


def create_deep_proxystore_serializer(*, policy: Type) -> ProxyStoreDeepSerializer:
    """Creates a serializer but does not register with global system - so this
    can be used in testing."""

    store = Store(name='parsl_store', connector=FileConnector(store_dir="/tmp"))
    register_store(store)
    return ProxyStoreDeepSerializer(store=store, policy=policy)
